{
  "timestamp": "2025-07-29T16:26:52.691227",
  "timestamp_unix": 1753824412.691227,
  "hook_type": "PostToolUse",
  "tool_name": "Read",
  "session_id": "54fdad9f-00f2-4c7a-8f11-7da7b149c513",
  "transcript_path": "/Users/bdmorin/.claude/projects/-Users-bdmorin-src-claude-hooks/54fdad9f-00f2-4c7a-8f11-7da7b149c513.jsonl",
  "cwd": "/Users/bdmorin/src/claude-hooks",
  "environment": {
    "python_version": "3.12.10 (main, Apr  9 2025, 03:49:38) [Clang 20.1.0 ]",
    "platform": "darwin",
    "eyelet_version": "0.2.0",
    "env_vars": {
      "CLAUDE_CODE_ENTRYPOINT": "cli",
      "CLAUDE_PROJECT_DIR": "/Users/bdmorin/src/claude-hooks",
      "CLAUDE_CODE_ENABLE_TELEMETRY": "1"
    }
  },
  "input_data": {
    "session_id": "54fdad9f-00f2-4c7a-8f11-7da7b149c513",
    "transcript_path": "/Users/bdmorin/.claude/projects/-Users-bdmorin-src-claude-hooks/54fdad9f-00f2-4c7a-8f11-7da7b149c513.jsonl",
    "cwd": "/Users/bdmorin/src/claude-hooks",
    "hook_event_name": "PostToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/bdmorin/src/claude-hooks/src/eyelet/services/sqlite_migrations.py"
    },
    "tool_response": {
      "type": "text",
      "file": {
        "filePath": "/Users/bdmorin/src/claude-hooks/src/eyelet/services/sqlite_migrations.py",
        "content": "\"\"\"SQLite schema migration system for Eyelet.\"\"\"\n\nfrom pathlib import Path\n\nfrom eyelet.services.sqlite_connection import ProcessLocalConnection, sqlite_retry\n\n# Migration format: (version, description, SQL)\nMIGRATIONS: list[tuple[int, str, str]] = [\n    (1, \"Initial schema\", \"\"\"\n        -- Initial schema is handled by SQLiteLogger.SCHEMA\n        -- This migration is a placeholder\n    \"\"\"),\n\n    # Future migrations will be added here\n    # (2, \"Add user_id column\", \"\"\"\n    #     ALTER TABLE hooks ADD COLUMN user_id TEXT;\n    #     CREATE INDEX idx_user_id ON hooks(user_id);\n    # \"\"\"),\n]\n\n\nclass MigrationManager:\n    \"\"\"Manages SQLite schema migrations using PRAGMA user_version.\"\"\"\n\n    def __init__(self, db_path: Path):\n        \"\"\"Initialize migration manager.\n\n        Args:\n            db_path: Path to SQLite database\n        \"\"\"\n        self.db_path = db_path\n        self._conn_manager = ProcessLocalConnection(db_path)\n\n    def get_current_version(self) -> int:\n        \"\"\"Get current schema version from database.\"\"\"\n        conn = self._conn_manager.connection\n        result = conn.execute(\"PRAGMA user_version\").fetchone()\n        return result[0] if result else 0\n\n    def set_version(self, version: int):\n        \"\"\"Set schema version in database.\"\"\"\n        conn = self._conn_manager.connection\n        conn.execute(f\"PRAGMA user_version = {version}\")\n\n    @sqlite_retry(max_attempts=5)\n    def migrate(self) -> list[str]:\n        \"\"\"Run pending migrations.\n\n        Returns:\n            List of migration descriptions that were applied\n        \"\"\"\n        current_version = self.get_current_version()\n        applied = []\n\n        conn = self._conn_manager.connection\n\n        for version, description, sql in MIGRATIONS:\n            if version > current_version:\n                # Begin transaction for this migration\n                conn.execute(\"BEGIN EXCLUSIVE\")\n                try:\n                    # Execute migration SQL\n                    if sql.strip():  # Skip empty migrations\n                        conn.executescript(sql)\n\n                    # Update version\n                    self.set_version(version)\n\n                    # Commit transaction\n                    conn.execute(\"COMMIT\")\n\n                    applied.append(f\"v{version}: {description}\")\n\n                except Exception as e:\n                    # Rollback on error\n                    conn.execute(\"ROLLBACK\")\n                    raise RuntimeError(f\"Migration {version} failed: {e}\")\n\n        return applied\n\n    def needs_migration(self) -> bool:\n        \"\"\"Check if database needs migration.\"\"\"\n        current_version = self.get_current_version()\n        latest_version = MIGRATIONS[-1][0] if MIGRATIONS else 0\n        return current_version < latest_version\n\n    def get_pending_migrations(self) -> list[tuple[int, str]]:\n        \"\"\"Get list of pending migrations.\n\n        Returns:\n            List of (version, description) tuples\n        \"\"\"\n        current_version = self.get_current_version()\n        pending = []\n\n        for version, description, _ in MIGRATIONS:\n            if version > current_version:\n                pending.append((version, description))\n\n        return pending\n",
        "numLines": 101,
        "startLine": 1,
        "totalLines": 101
      }
    }
  },
  "metadata": {
    "log_file": "/Users/bdmorin/src/claude-hooks/eyelet-hooks/PostToolUse/Read/2025-07-29/20250729_162652_691227_PostToolUse_Read.json",
    "log_dir": "/Users/bdmorin/src/claude-hooks/eyelet-hooks/PostToolUse/Read/2025-07-29",
    "project_dir": "/Users/bdmorin/src/claude-hooks"
  },
  "execution": {
    "status": "success",
    "duration_ms": 3,
    "output_data": {
      "action": "logged"
    },
    "error_message": null
  },
  "completed_at": "2025-07-29T16:26:52.695256"
}