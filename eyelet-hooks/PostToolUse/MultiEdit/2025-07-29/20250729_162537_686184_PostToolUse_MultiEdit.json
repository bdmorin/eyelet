{
  "timestamp": "2025-07-29T16:25:37.686184",
  "timestamp_unix": 1753824337.686184,
  "hook_type": "PostToolUse",
  "tool_name": "MultiEdit",
  "session_id": "54fdad9f-00f2-4c7a-8f11-7da7b149c513",
  "transcript_path": "/Users/bdmorin/.claude/projects/-Users-bdmorin-src-claude-hooks/54fdad9f-00f2-4c7a-8f11-7da7b149c513.jsonl",
  "cwd": "/Users/bdmorin/src/claude-hooks",
  "environment": {
    "python_version": "3.12.10 (main, Apr  9 2025, 03:49:38) [Clang 20.1.0 ]",
    "platform": "darwin",
    "eyelet_version": "0.2.0",
    "env_vars": {
      "CLAUDE_CODE_ENTRYPOINT": "cli",
      "CLAUDE_PROJECT_DIR": "/Users/bdmorin/src/claude-hooks",
      "CLAUDE_CODE_ENABLE_TELEMETRY": "1"
    }
  },
  "input_data": {
    "session_id": "54fdad9f-00f2-4c7a-8f11-7da7b149c513",
    "transcript_path": "/Users/bdmorin/.claude/projects/-Users-bdmorin-src-claude-hooks/54fdad9f-00f2-4c7a-8f11-7da7b149c513.jsonl",
    "cwd": "/Users/bdmorin/src/claude-hooks",
    "hook_event_name": "PostToolUse",
    "tool_name": "MultiEdit",
    "tool_input": {
      "file_path": "/Users/bdmorin/src/claude-hooks/src/eyelet/services/sqlite_connection.py",
      "edits": [
        {
          "old_string": "            if self._conn:\n                try:\n                    self._conn.close()\n                except:\n                    pass",
          "new_string": "            if self._conn:\n                try:\n                    self._conn.close()\n                except Exception:\n                    pass"
        },
        {
          "old_string": "        if self._conn:\n            try:\n                self._conn.close()\n            except:\n                pass",
          "new_string": "        if self._conn:\n            try:\n                self._conn.close()\n            except Exception:\n                pass"
        },
        {
          "old_string": "        for conn in self._connections:\n            try:\n                conn.close()\n            except:\n                pass",
          "new_string": "        for conn in self._connections:\n            try:\n                conn.close()\n            except Exception:\n                pass"
        }
      ]
    },
    "tool_response": {
      "filePath": "/Users/bdmorin/src/claude-hooks/src/eyelet/services/sqlite_connection.py",
      "edits": [
        {
          "old_string": "            if self._conn:\n                try:\n                    self._conn.close()\n                except:\n                    pass",
          "new_string": "            if self._conn:\n                try:\n                    self._conn.close()\n                except Exception:\n                    pass",
          "replace_all": false
        },
        {
          "old_string": "        if self._conn:\n            try:\n                self._conn.close()\n            except:\n                pass",
          "new_string": "        if self._conn:\n            try:\n                self._conn.close()\n            except Exception:\n                pass",
          "replace_all": false
        },
        {
          "old_string": "        for conn in self._connections:\n            try:\n                conn.close()\n            except:\n                pass",
          "new_string": "        for conn in self._connections:\n            try:\n                conn.close()\n            except Exception:\n                pass",
          "replace_all": false
        }
      ],
      "originalFileContents": "\"\"\"Process-local SQLite connection management with best practices.\"\"\"\n\nimport os\nimport random\nimport sqlite3\nimport time\nfrom collections.abc import Callable\nfrom functools import wraps\nfrom pathlib import Path\nfrom typing import Any\n\n\nclass ProcessLocalConnection:\n    \"\"\"Thread-safe, process-local SQLite connection manager.\n    \n    Handles fork safety by creating new connections when process ID changes.\n    This is critical for multi-process scenarios like multiple Claude Code instances.\n    \"\"\"\n\n    def __init__(self, db_path: Path):\n        \"\"\"Initialize connection manager.\n        \n        Args:\n            db_path: Path to SQLite database file\n        \"\"\"\n        self.db_path = db_path\n        self._pid: int | None = None\n        self._conn: sqlite3.Connection | None = None\n\n    def _create_connection(self) -> sqlite3.Connection:\n        \"\"\"Create optimized SQLite connection with best practices.\"\"\"\n        # Ensure directory exists\n        self.db_path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Open connection with URI mode for better control\n        conn = sqlite3.connect(\n            f\"file:{self.db_path}?mode=rwc\",  # Read-write-create\n            uri=True,\n            timeout=60.0,  # High timeout for busy environments\n            isolation_level=None  # Autocommit mode for logging\n        )\n\n        # Enable optimizations\n        optimizations = [\n            \"PRAGMA journal_mode = WAL\",         # Write-Ahead Logging\n            \"PRAGMA synchronous = NORMAL\",       # Balance safety/speed\n            \"PRAGMA cache_size = -64000\",        # 64MB cache\n            \"PRAGMA temp_store = MEMORY\",        # RAM for temp tables\n            \"PRAGMA mmap_size = 268435456\",      # 256MB memory-mapped I/O\n            \"PRAGMA busy_timeout = 60000\",       # 60s timeout\n            \"PRAGMA wal_autocheckpoint = 1000\",  # Checkpoint every 1000 pages\n        ]\n\n        for pragma in optimizations:\n            conn.execute(pragma)\n\n        # Enable JSON1 extension features\n        conn.row_factory = sqlite3.Row\n\n        return conn\n\n    @property\n    def connection(self) -> sqlite3.Connection:\n        \"\"\"Get connection, creating new one if process changed.\"\"\"\n        current_pid = os.getpid()\n\n        # Create new connection if process changed (fork safety)\n        if self._pid != current_pid:\n            if self._conn:\n                try:\n                    self._conn.close()\n                except:\n                    pass\n            self._conn = self._create_connection()\n            self._pid = current_pid\n\n        return self._conn\n\n    def close(self):\n        \"\"\"Close connection if open.\"\"\"\n        if self._conn:\n            try:\n                self._conn.close()\n            except:\n                pass\n            self._conn = None\n            self._pid = None\n\n\ndef sqlite_retry(\n    max_attempts: int = 10,\n    base_delay: float = 0.05,\n    max_delay: float = 10.0,\n    exceptions: tuple = (sqlite3.OperationalError,)\n) -> Callable:\n    \"\"\"Decorator for SQLite operations with exponential backoff retry.\n    \n    Args:\n        max_attempts: Maximum number of retry attempts\n        base_delay: Initial delay in seconds\n        max_delay: Maximum delay between retries\n        exceptions: Tuple of exceptions to catch\n        \n    Returns:\n        Decorated function\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -> Any:\n            last_exception = None\n\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n\n                    # Check if it's a locking error\n                    if \"locked\" not in str(e).lower() and attempt == 0:\n                        # Not a lock error, don't retry\n                        raise\n\n                    if attempt < max_attempts - 1:\n                        # Calculate delay with exponential backoff\n                        delay = min(base_delay * (2 ** attempt), max_delay)\n\n                        # Add jitter to prevent thundering herd\n                        delay *= (0.5 + random.random())\n\n                        time.sleep(delay)\n                    else:\n                        # Final attempt failed\n                        raise last_exception\n\n            # Should never reach here\n            raise last_exception\n\n        return wrapper\n    return decorator\n\n\nclass ConnectionPool:\n    \"\"\"Simple connection pool for read-only connections.\"\"\"\n\n    def __init__(self, db_path: Path, pool_size: int = 5):\n        \"\"\"Initialize read-only connection pool.\n        \n        Args:\n            db_path: Path to SQLite database\n            pool_size: Number of connections to maintain\n        \"\"\"\n        self.db_path = db_path\n        self.pool_size = pool_size\n        self._connections: list[sqlite3.Connection] = []\n        self._available: list[bool] = []\n        self._init_pool()\n\n    def _init_pool(self):\n        \"\"\"Initialize connection pool with read-only connections.\"\"\"\n        for _ in range(self.pool_size):\n            conn = sqlite3.connect(\n                f\"file:{self.db_path}?mode=ro\",  # Read-only mode\n                uri=True,\n                timeout=10.0\n            )\n            conn.row_factory = sqlite3.Row\n            conn.execute(\"PRAGMA query_only = ON\")\n\n            self._connections.append(conn)\n            self._available.append(True)\n\n    def get_connection(self) -> sqlite3.Connection | None:\n        \"\"\"Get available connection from pool.\"\"\"\n        for i, available in enumerate(self._available):\n            if available:\n                self._available[i] = False\n                return self._connections[i]\n        return None\n\n    def return_connection(self, conn: sqlite3.Connection):\n        \"\"\"Return connection to pool.\"\"\"\n        try:\n            idx = self._connections.index(conn)\n            self._available[idx] = True\n        except ValueError:\n            pass  # Connection not from this pool\n\n    def close_all(self):\n        \"\"\"Close all connections in pool.\"\"\"\n        for conn in self._connections:\n            try:\n                conn.close()\n            except:\n                pass\n        self._connections.clear()\n        self._available.clear()\n",
      "structuredPatch": [
        {
          "oldStart": 69,
          "oldLines": 7,
          "newStart": 69,
          "newLines": 7,
          "lines": [
            "             if self._conn:",
            "                 try:",
            "                     self._conn.close()",
            "-                except:",
            "+                except Exception:",
            "                     pass",
            "             self._conn = self._create_connection()",
            "             self._pid = current_pid"
          ]
        },
        {
          "oldStart": 81,
          "oldLines": 7,
          "newStart": 81,
          "newLines": 7,
          "lines": [
            "         if self._conn:",
            "             try:",
            "                 self._conn.close()",
            "-            except:",
            "+            except Exception:",
            "                 pass",
            "             self._conn = None",
            "             self._pid = None"
          ]
        },
        {
          "oldStart": 190,
          "oldLines": 7,
          "newStart": 190,
          "newLines": 7,
          "lines": [
            "         for conn in self._connections:",
            "             try:",
            "                 conn.close()",
            "-            except:",
            "+            except Exception:",
            "                 pass",
            "         self._connections.clear()",
            "         self._available.clear()"
          ]
        }
      ],
      "userModified": false
    }
  },
  "metadata": {
    "log_file": "/Users/bdmorin/src/claude-hooks/eyelet-hooks/PostToolUse/MultiEdit/2025-07-29/20250729_162537_686184_PostToolUse_MultiEdit.json",
    "log_dir": "/Users/bdmorin/src/claude-hooks/eyelet-hooks/PostToolUse/MultiEdit/2025-07-29",
    "project_dir": "/Users/bdmorin/src/claude-hooks"
  },
  "execution": {
    "status": "success",
    "duration_ms": 4,
    "output_data": {
      "action": "logged"
    },
    "error_message": null
  },
  "completed_at": "2025-07-29T16:25:37.690701"
}