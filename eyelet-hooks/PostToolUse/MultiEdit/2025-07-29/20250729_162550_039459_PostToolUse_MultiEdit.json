{
  "timestamp": "2025-07-29T16:25:50.039459",
  "timestamp_unix": 1753824350.039459,
  "hook_type": "PostToolUse",
  "tool_name": "MultiEdit",
  "session_id": "54fdad9f-00f2-4c7a-8f11-7da7b149c513",
  "transcript_path": "/Users/bdmorin/.claude/projects/-Users-bdmorin-src-claude-hooks/54fdad9f-00f2-4c7a-8f11-7da7b149c513.jsonl",
  "cwd": "/Users/bdmorin/src/claude-hooks",
  "environment": {
    "python_version": "3.12.10 (main, Apr  9 2025, 03:49:38) [Clang 20.1.0 ]",
    "platform": "darwin",
    "eyelet_version": "0.2.0",
    "env_vars": {
      "CLAUDE_CODE_ENTRYPOINT": "cli",
      "CLAUDE_PROJECT_DIR": "/Users/bdmorin/src/claude-hooks",
      "CLAUDE_CODE_ENABLE_TELEMETRY": "1"
    }
  },
  "input_data": {
    "session_id": "54fdad9f-00f2-4c7a-8f11-7da7b149c513",
    "transcript_path": "/Users/bdmorin/.claude/projects/-Users-bdmorin-src-claude-hooks/54fdad9f-00f2-4c7a-8f11-7da7b149c513.jsonl",
    "cwd": "/Users/bdmorin/src/claude-hooks",
    "hook_event_name": "PostToolUse",
    "tool_name": "MultiEdit",
    "tool_input": {
      "file_path": "/Users/bdmorin/src/claude-hooks/src/eyelet/services/sqlite_logger.py",
      "edits": [
        {
          "old_string": "        except:\n            return \"unknown\"",
          "new_string": "        except Exception:\n            return \"unknown\"",
          "replace_all": true
        }
      ]
    },
    "tool_response": {
      "filePath": "/Users/bdmorin/src/claude-hooks/src/eyelet/services/sqlite_logger.py",
      "edits": [
        {
          "old_string": "        except:\n            return \"unknown\"",
          "new_string": "        except Exception:\n            return \"unknown\"",
          "replace_all": true
        }
      ],
      "originalFileContents": "\"\"\"SQLite logging implementation with retry logic.\"\"\"\n\nimport json\nimport socket\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any\n\nfrom eyelet.domain.hooks import HookData\nfrom eyelet.services.sqlite_connection import ProcessLocalConnection, sqlite_retry\n\n\nclass SQLiteLogger:\n    \"\"\"SQLite logger with best practices for high-concurrency logging.\"\"\"\n\n    # Database schema with modern SQLite features\n    SCHEMA = \"\"\"\n    CREATE TABLE IF NOT EXISTS hooks (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        timestamp REAL NOT NULL,\n        timestamp_iso TEXT NOT NULL,\n        session_id TEXT NOT NULL,\n        hook_type TEXT NOT NULL,\n        tool_name TEXT,\n        status TEXT,\n        duration_ms INTEGER,\n        hostname TEXT,\n        ip_address TEXT,\n        project_dir TEXT,\n        -- Store as BLOB for JSONB optimization in SQLite 3.45+\n        data BLOB NOT NULL CHECK(json_valid(data)),\n        -- Generated columns for frequently queried JSON fields\n        error_code TEXT GENERATED ALWAYS AS (json_extract(data, '$.execution.error_message')) STORED,\n        git_branch TEXT GENERATED ALWAYS AS (json_extract(data, '$.metadata.git_branch')) STORED\n    );\n    \n    -- Indexes for common queries\n    CREATE INDEX IF NOT EXISTS idx_timestamp ON hooks(timestamp);\n    CREATE INDEX IF NOT EXISTS idx_session_id ON hooks(session_id);\n    CREATE INDEX IF NOT EXISTS idx_hook_type ON hooks(hook_type);\n    CREATE INDEX IF NOT EXISTS idx_tool_name ON hooks(tool_name);\n    CREATE INDEX IF NOT EXISTS idx_project_dir ON hooks(project_dir);\n    CREATE INDEX IF NOT EXISTS idx_error_code ON hooks(error_code) WHERE error_code IS NOT NULL;\n    CREATE INDEX IF NOT EXISTS idx_git_branch ON hooks(git_branch) WHERE git_branch IS NOT NULL;\n    \n    -- Composite index for time-based queries by type\n    CREATE INDEX IF NOT EXISTS idx_type_timestamp ON hooks(hook_type, timestamp DESC);\n    \"\"\"\n\n    def __init__(self, db_path: Path):\n        \"\"\"Initialize SQLite logger.\n        \n        Args:\n            db_path: Path to SQLite database file\n        \"\"\"\n        self.db_path = db_path\n        self._conn_manager = ProcessLocalConnection(db_path)\n        self._initialize_db()\n\n    @sqlite_retry(max_attempts=5)\n    def _initialize_db(self) -> None:\n        \"\"\"Initialize database with schema.\"\"\"\n        conn = self._conn_manager.connection\n        conn.executescript(self.SCHEMA)\n\n        # Set initial schema version\n        current_version = conn.execute(\"PRAGMA user_version\").fetchone()[0]\n        if current_version == 0:\n            conn.execute(\"PRAGMA user_version = 1\")\n\n    def _get_hostname(self) -> str:\n        \"\"\"Get hostname safely.\"\"\"\n        try:\n            return socket.gethostname()\n        except:\n            return \"unknown\"\n\n    def _get_ip_address(self) -> str:\n        \"\"\"Get IP address safely.\"\"\"\n        try:\n            hostname = socket.gethostname()\n            return socket.gethostbyname(hostname)\n        except:\n            return \"unknown\"\n\n    @sqlite_retry(max_attempts=10, base_delay=0.05)\n    def log_hook(self, hook_data: HookData) -> bool:\n        \"\"\"Log hook data to SQLite with automatic retry.\n        \n        Args:\n            hook_data: Hook data to log\n            \n        Returns:\n            True if successful, False otherwise\n        \n        Raises:\n            sqlite3.OperationalError: If database is locked after all retries\n        \"\"\"\n        # Extract core fields for indexing\n        timestamp = hook_data.timestamp_unix\n        timestamp_iso = hook_data.timestamp\n        session_id = hook_data.session_id\n        hook_type = hook_data.hook_type\n        tool_name = hook_data.tool_name or None\n        status = hook_data.execution.status if hook_data.execution else \"unknown\"\n        duration_ms = hook_data.execution.duration_ms if hook_data.execution else None\n        hostname = self._get_hostname()\n        ip_address = self._get_ip_address()\n        project_dir = str(hook_data.cwd)\n\n        # Full data as JSON (with Path conversion)\n        data_dict = hook_data.model_dump()\n        # Convert Path objects to strings\n        if 'cwd' in data_dict and hasattr(data_dict['cwd'], '__fspath__'):\n            data_dict['cwd'] = str(data_dict['cwd'])\n        data_json = json.dumps(data_dict, default=str)\n\n        # SQL insert statement\n        sql = \"\"\"\n        INSERT INTO hooks (\n            timestamp, timestamp_iso, session_id, hook_type, tool_name,\n            status, duration_ms, hostname, ip_address, project_dir, data\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\"\n\n        values = (\n            timestamp, timestamp_iso, session_id, hook_type, tool_name,\n            status, duration_ms, hostname, ip_address, project_dir, data_json\n        )\n\n        try:\n            conn = self._conn_manager.connection\n            conn.execute(sql, values)\n            return True\n        except Exception:\n            # Re-raise to trigger retry decorator\n            raise\n\n    def query_hooks(\n        self,\n        hook_type: str | None = None,\n        tool_name: str | None = None,\n        session_id: str | None = None,\n        since: datetime | None = None,\n        limit: int = 100\n    ) -> list[dict[str, Any]]:\n        \"\"\"Query hooks from database.\n        \n        Args:\n            hook_type: Filter by hook type\n            tool_name: Filter by tool name\n            session_id: Filter by session ID\n            since: Filter by timestamp (hooks after this time)\n            limit: Maximum number of results\n            \n        Returns:\n            List of hook records\n        \"\"\"\n        conditions = []\n        params = []\n\n        if hook_type:\n            conditions.append(\"hook_type = ?\")\n            params.append(hook_type)\n\n        if tool_name:\n            conditions.append(\"tool_name = ?\")\n            params.append(tool_name)\n\n        if session_id:\n            conditions.append(\"session_id = ?\")\n            params.append(session_id)\n\n        if since:\n            conditions.append(\"timestamp > ?\")\n            params.append(since.timestamp())\n\n        where_clause = \" AND \".join(conditions) if conditions else \"1=1\"\n\n        sql = f\"\"\"\n        SELECT * FROM hooks\n        WHERE {where_clause}\n        ORDER BY timestamp DESC\n        LIMIT ?\n        \"\"\"\n        params.append(limit)\n\n        conn = self._conn_manager.connection\n        cursor = conn.execute(sql, params)\n        return [dict(row) for row in cursor.fetchall()]\n\n    def batch_insert(self, hook_data_list: list[HookData]) -> int:\n        \"\"\"Batch insert multiple hook records for better performance.\n        \n        Args:\n            hook_data_list: List of hook data to insert\n            \n        Returns:\n            Number of records inserted\n        \"\"\"\n        if not hook_data_list:\n            return 0\n\n        sql = \"\"\"\n        INSERT INTO hooks (\n            timestamp, timestamp_iso, session_id, hook_type, tool_name,\n            status, duration_ms, hostname, ip_address, project_dir, data\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\"\n\n        values_list = []\n        for hook_data in hook_data_list:\n            values = (\n                hook_data.timestamp_unix,\n                hook_data.timestamp,\n                hook_data.session_id,\n                hook_data.hook_type,\n                hook_data.tool_name or None,\n                hook_data.execution.status if hook_data.execution else \"unknown\",\n                hook_data.execution.duration_ms if hook_data.execution else None,\n                self._get_hostname(),\n                self._get_ip_address(),\n                str(hook_data.cwd),\n                json.dumps(hook_data.model_dump())\n            )\n            values_list.append(values)\n\n        @sqlite_retry(max_attempts=10)\n        def _batch_insert():\n            conn = self._conn_manager.connection\n            with conn:\n                conn.executemany(sql, values_list)\n            return len(values_list)\n\n        return _batch_insert()\n",
      "structuredPatch": [
        {
          "oldStart": 72,
          "oldLines": 7,
          "newStart": 72,
          "newLines": 7,
          "lines": [
            "         \"\"\"Get hostname safely.\"\"\"",
            "         try:",
            "             return socket.gethostname()",
            "-        except:",
            "+        except Exception:",
            "             return \"unknown\"",
            " ",
            "     def _get_ip_address(self) -> str:"
          ]
        },
        {
          "oldStart": 80,
          "oldLines": 7,
          "newStart": 80,
          "newLines": 7,
          "lines": [
            "         try:",
            "             hostname = socket.gethostname()",
            "             return socket.gethostbyname(hostname)",
            "-        except:",
            "+        except Exception:",
            "             return \"unknown\"",
            " ",
            "     @sqlite_retry(max_attempts=10, base_delay=0.05)"
          ]
        }
      ],
      "userModified": false
    }
  },
  "metadata": {
    "log_file": "/Users/bdmorin/src/claude-hooks/eyelet-hooks/PostToolUse/MultiEdit/2025-07-29/20250729_162550_039459_PostToolUse_MultiEdit.json",
    "log_dir": "/Users/bdmorin/src/claude-hooks/eyelet-hooks/PostToolUse/MultiEdit/2025-07-29",
    "project_dir": "/Users/bdmorin/src/claude-hooks"
  },
  "execution": {
    "status": "success",
    "duration_ms": 4,
    "output_data": {
      "action": "logged"
    },
    "error_message": null
  },
  "completed_at": "2025-07-29T16:25:50.043927"
}